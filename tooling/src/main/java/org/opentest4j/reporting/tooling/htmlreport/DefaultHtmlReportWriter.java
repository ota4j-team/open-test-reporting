package org.opentest4j.reporting.tooling.htmlreport;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonSubTypes.Type;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.json.JsonSanitizer;
import org.opentest4j.reporting.events.core.Result;
import org.opentest4j.reporting.schema.Namespace;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import static java.util.Objects.requireNonNull;
import static org.joox.JOOX.$;
import static org.opentest4j.reporting.tooling.util.DomUtils.matches;
import static org.opentest4j.reporting.tooling.util.DomUtils.stream;

public class DefaultHtmlReportWriter implements HtmlReportWriter {

    @Override
    public void writeHtmlReport(Path xmlFile, Path htmlFile) throws Exception {

        // TODO Check whether XML file is in hierarchical format. If not, convert it first

        var rootElement = parseDom(xmlFile);
        var idGenerator = new IdGenerator();
        var tree = new LinkedHashMap<String, List<String>>();
        var testNodes = new ArrayList<TestNode>();
        var roots = new ArrayList<String>();

        for (Node child = rootElement.getFirstChild(); child != null; child = child.getNextSibling()) {
            if (child instanceof Element && Namespace.REPORTING_HIERARCHY.getUri().equals(child.getNamespaceURI())
                    && "root".equals(child.getLocalName())) {
                roots.add(visitNode((Element) child, idGenerator, new ArrayDeque<>(), tree, testNodes));
            }
        }

        var jsonMapper = new ObjectMapper();
        var json = JsonSanitizer.sanitize(jsonMapper.writeValueAsString(roots));
        var javaScript = "\n    globalThis.roots = " + json + ";";

        json = JsonSanitizer.sanitize(jsonMapper.writeValueAsString(tree));
        javaScript += "\n    globalThis.children = " + json + ";";

        jsonMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
        json = JsonSanitizer.sanitize(jsonMapper.writeValueAsString(testNodes));
        javaScript += "\n    globalThis.testNodes = " + json + ";";

        var content = readTemplate().replace("<script src=\"./init.js\"></script>", "<script>" + javaScript + "\n  </script>");
        Files.writeString(htmlFile, content);
    }

    static class TestNode {

        public final String id;
        public final String name;
        public final String status;
        public final String duration;
        public final List<Section> sections = new ArrayList<>();

        TestNode(String id, String name, String status, String duration) {
            this.id = id;
            this.name = name;
            this.status = status;
            this.duration = duration;
        }
    }

    static class Section {

        public final String title;
        public final List<Block> blocks = new ArrayList<>();

        Section(String title) {
            this.title = title;
        }
    }

    @JsonTypeInfo(
            use = JsonTypeInfo.Id.NAME,
            property = "type")
    @JsonSubTypes({
            @Type(value = Paragraph.class, name = "p"),
            @Type(value = PreFormattedOutput.class, name = "pre"),
            @Type(value = KeyValuePairs.class, name = "kvp"),
            @Type(value = Subsections.class, name = "sub"),
            @Type(value = Labels.class, name = "labels")
    })
    static abstract class Block {
    }

    static class PreFormattedOutput extends Block {

        public final String content;

        PreFormattedOutput(String content) {
            this.content = content;
        }
    }

    static class Paragraph extends Block {

        public final String content;

        Paragraph(String content) {
            this.content = content;
        }
    }

    static class KeyValuePairs extends Block {

        public final Map<String, String> content;

        KeyValuePairs(Map<String, String> content) {
            this.content = content;
        }
    }

    static class Subsections extends Block {

        public final List<Section> content;

        Subsections(List<Section> content) {
            this.content = content;
        }
    }

    static class Labels extends Block {

        public final List<String> content;

        Labels(List<String> content) {
            this.content = content;
        }
    }

    private String visitNode(Element node, IdGenerator idGenerator, Deque<String> parentIds, Map<String, List<String>> children, List<TestNode> testNodes) {
        String currentId = idGenerator.next();

        String status = stream(node.getChildNodes()) //
                .filter(it -> it instanceof Element && matches(Result.ELEMENT, (Element) it))
                .findAny()
                .map(it -> ((Element) it).getAttribute(Result.STATUS.getSimpleName()))
                .orElse(null);

        var testNode = new TestNode(currentId, node.getAttribute("name"), status, node.getAttribute("duration"));
        testNodes.add(testNode);

        addSections(node, testNode);

        if (!parentIds.isEmpty()) {
            String parentId = parentIds.peek();
            children.computeIfAbsent(parentId, __ -> new ArrayList<>());
            children.get(parentId).add(currentId);
        }
        parentIds.push(currentId);
        for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {
            if (child instanceof Element && Namespace.REPORTING_HIERARCHY.getUri().equals(child.getNamespaceURI())
                    && "child".equals(child.getLocalName())) {
                visitNode((Element) child, idGenerator, parentIds, children, testNodes);
            }
        }
        parentIds.pop();

        return currentId;
    }

    private void addSections(Element element, TestNode node) {
        node.sections.add(createTagsSection(element));
        node.sections.add(createSourcesSection(element));
        node.sections.add(createAttachmentsSection(element));
    }

    private static Section createTagsSection(Element element) {
        Section section = new Section("Tags");
        var tags = $(element)
                .child("metadata")
                .child("tags")
                .children("tag")
                .map(e -> e.element().getTextContent());
        if (tags.isEmpty()) {
            section.blocks.add(new Paragraph("No tags"));
        } else {
            section.blocks.add(new Labels(tags));
        }
        return section;
    }

    private static Section createSourcesSection(Element element) {
        Section section = new Section("Sources");
        var children = $(element).children("sources").children().get();
        if (children.isEmpty()) {
            section.blocks.add(new Paragraph("No source information"));
        } else {
            var content = new ArrayList<Section>();
            section.blocks.add(new Subsections(content));
            children.stream()
                    .map(child -> {
                        var type = child.getLocalName();
                        if (child.getLocalName().endsWith("Source")) {
                            type = child.getLocalName().substring(0, child.getLocalName().length() - "Source".length());
                        }
                        var subsection = new Section(capitalize(type));
                        var attributes = new LinkedHashMap<String, String>();
                        stream(child.getAttributes()).forEach(it -> attributes.put(it.getNodeName(), it.getNodeValue()));
                        subsection.blocks.add(new KeyValuePairs(attributes));
                        return subsection;
                    })
                    .forEach(content::add);
        }
        return section;
    }

    private static Section createAttachmentsSection(Element element) {
        Section section = new Section("Attachments");
        var children = $(element).children("attachments").children().get();
        if (children.isEmpty()) {
            section.blocks.add(new Paragraph("No attachments"));
        } else {
            var content = new ArrayList<Section>();
            section.blocks.add(new Subsections(content));
            children.stream()
                    .map(child -> {
                        var type = child.getLocalName();
                        var subsection = new Section(capitalize(type));
                        var attributes = new LinkedHashMap<String, String>();
                        stream(child.getAttributes()).forEach(it -> attributes.put(it.getNodeName(), it.getNodeValue()));
                        if ("data".equals(child.getLocalName())) {
                            $(child).children("entry").forEach(entry -> {
                                var key = entry.getAttribute("key");
                                var value = entry.getTextContent();
                                attributes.put(key, value);
                            });
                        }
                        subsection.blocks.add(new KeyValuePairs(attributes));
                        return subsection;
                    })
                    .forEach(content::add);
        }
        return section;
    }

    private static String capitalize(String value) {
        return value.substring(0, 1).toUpperCase(Locale.ROOT) + value.substring(1);
    }

    static class IdGenerator {
        private int nextId = 1;

        String next() {
            return Integer.toString(nextId++);
        }
    }

    private static Element parseDom(Path xmlFile) throws ParserConfigurationException, SAXException, IOException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        DocumentBuilder builder = factory.newDocumentBuilder();

        Document sourceDocument = builder.parse(xmlFile.toFile());
        return sourceDocument.getDocumentElement();
    }

    private String readTemplate() throws IOException {
        try (var template = getClass().getResourceAsStream("template.html")) {
            return new String(requireNonNull(template).readAllBytes());
        }
    }
}
