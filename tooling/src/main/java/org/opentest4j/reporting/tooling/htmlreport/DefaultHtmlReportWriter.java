package org.opentest4j.reporting.tooling.htmlreport;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonSubTypes.Type;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.json.JsonSanitizer;
import org.joox.Match;
import org.opentest4j.reporting.events.core.Result;
import org.opentest4j.reporting.schema.Namespace;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.time.Duration;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;

import static java.util.Objects.requireNonNull;
import static org.joox.JOOX.$;
import static org.opentest4j.reporting.tooling.util.DomUtils.matches;
import static org.opentest4j.reporting.tooling.util.DomUtils.stream;

public class DefaultHtmlReportWriter implements HtmlReportWriter {

    @Override
    public void writeHtmlReport(Path xmlFile, Path htmlFile) throws Exception {

        // TODO Check whether XML file is in hierarchical format. If not, convert it first

        var rootElement = parseDom(xmlFile);
        var idGenerator = new IdGenerator();

        var execution = new Execution(idGenerator.next(), "Execution");
        addSections(rootElement, execution);

        for (Node child = rootElement.getFirstChild(); child != null; child = child.getNextSibling()) {
            if (child instanceof Element && Namespace.REPORTING_HIERARCHY.getUri().equals(child.getNamespaceURI())
                    && "root".equals(child.getLocalName())) {
                var root = visitNode((Element) child, idGenerator, new ArrayDeque<>(), execution);
                execution.durationMillis += root.durationMillis;
                execution.roots.add(root.id);
            }
        }

        var jsonMapper = new ObjectMapper();
        jsonMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);

        var json = JsonSanitizer.sanitize(jsonMapper.writeValueAsString(List.of(execution)));
        var javaScript = "globalThis.testExecutions = " + json + ";";

        var content = readTemplate().replace("<script src=\"./init.js\"></script>", "<script>\n    " + javaScript + "\n  </script>");
        Files.writeString(htmlFile, content);
    }

    static class Execution {

        public final String id;
        public final String name;
        public long durationMillis;

        public final List<Section> sections = new ArrayList<>();

        public final List<String> roots = new ArrayList<>();
        public final Map<String, List<String>> children = new LinkedHashMap<>();
        public final List<TestNode> testNodes = new ArrayList<>();

        public Execution(String id, String name) {
            this.id = id;
            this.name = name;
        }
    }

    static class TestNode {

        public final String id;
        public final String name;
        public final long durationMillis;

        public final String status;

        public final List<Section> sections = new ArrayList<>();

        TestNode(String id, String name, long durationMillis, String status) {
            this.id = id;
            this.name = name;
            this.durationMillis = durationMillis;
            this.status = status;
        }
    }

    static class Section {

        public final String title;
        public final List<Block> blocks = new ArrayList<>();

        Section(String title) {
            this.title = title;
        }
    }

    @JsonTypeInfo(
            use = JsonTypeInfo.Id.NAME,
            property = "type")
    @JsonSubTypes({
            @Type(value = Paragraph.class, name = "p"),
            @Type(value = PreFormattedOutput.class, name = "pre"),
            @Type(value = KeyValuePairs.class, name = "kvp"),
            @Type(value = Subsections.class, name = "sub"),
            @Type(value = Labels.class, name = "labels")
    })
    static abstract class Block {
    }

    static class PreFormattedOutput extends Block {

        public final String content;

        PreFormattedOutput(String content) {
            this.content = content;
        }
    }

    static class Paragraph extends Block {

        public final String content;

        Paragraph(String content) {
            this.content = content;
        }
    }

    static class KeyValuePairs extends Block {

        public final Map<String, String> content;

        KeyValuePairs(Map<String, String> content) {
            this.content = content;
        }
    }

    static class Subsections extends Block {

        public final List<Section> content;

        Subsections(List<Section> content) {
            this.content = content;
        }
    }

    static class Labels extends Block {

        public final List<String> content;

        Labels(List<String> content) {
            this.content = content;
        }
    }

    private TestNode visitNode(Element node, IdGenerator idGenerator, Deque<String> parentIds, Execution execution) {
        String currentId = idGenerator.next();

        String status = stream(node.getChildNodes()) //
                .filter(it -> it instanceof Element && matches(Result.ELEMENT, (Element) it))
                .findAny()
                .map(it -> ((Element) it).getAttribute(Result.STATUS.getSimpleName()))
                .orElse(null);

        var duration = Duration.parse(node.getAttribute("duration"));
        var testNode = new TestNode(currentId, node.getAttribute("name"), duration.toMillis(), status);
        execution.testNodes.add(testNode);

        addSections(node, testNode);

        if (!parentIds.isEmpty()) {
            String parentId = parentIds.peek();
            execution.children.computeIfAbsent(parentId, __ -> new ArrayList<>());
            execution.children.get(parentId).add(currentId);
        }
        parentIds.push(currentId);
        for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {
            if (child instanceof Element && Namespace.REPORTING_HIERARCHY.getUri().equals(child.getNamespaceURI())
                    && "child".equals(child.getLocalName())) {
                visitNode((Element) child, idGenerator, parentIds, execution);
            }
        }
        parentIds.pop();

        return testNode;
    }

    private void addSections(Element element, Execution execution) {
        var infrastructure = $(element).child("infrastructure");

        createInfrastructureSection(infrastructure).ifPresent(execution.sections::add);
        createJvmSection(infrastructure).ifPresent(execution.sections::add);
    }

    private static Optional<Section> createInfrastructureSection(Match infrastructure) {
        var table = new LinkedHashMap<String, String>();
        addToTable(infrastructure, "hostName", "Hostname", table);
        addToTable(infrastructure, "userName", "Username", table);
        addToTable(infrastructure, "operatingSystem", "Operating system", table);
        addToTable(infrastructure, "cpuCores", "CPU cores", table);

        if (table.isEmpty()) {
            return Optional.empty();
        }

        var section = new Section("Infrastructure");
        section.blocks.add(new KeyValuePairs(table));
        return Optional.of(section);
    }

    private static Optional<Section> createJvmSection(Match infrastructure) {
        var table = new LinkedHashMap<String, String>();
        addToTable(infrastructure, "javaVersion", "Java version", table);
        addToTable(infrastructure, "fileEncoding", "File encoding", table);
        String maxHeapSize = infrastructure.child("heapSize").attr("max");
        if (maxHeapSize != null) {
            table.put("Max heap size", String.format("%s (%s bytes)", toHumanReadableFormat(Long.parseLong(maxHeapSize)), maxHeapSize));
        }

        if (table.isEmpty()) {
            return Optional.empty();
        }

        var section = new Section("Java Virtual Machine");
        section.blocks.add(new KeyValuePairs(table));
        return Optional.of(section);
    }

    // Adapted from https://www.baeldung.com/java-human-readable-byte-size#using-the-longnumberofleadingzeros-method
    private static String toHumanReadableFormat(long size) {
        if (size < 1024) return size + " B";
        int unitIdx = (63 - Long.numberOfLeadingZeros(size)) / 10;
        return formatSize(size, 1L << (unitIdx * 10), " KMGTPE".charAt(unitIdx) + "iB");
    }

    private static String formatSize(long size, long divider, String unitName) {
        return new DecimalFormat("#.##", new DecimalFormatSymbols(Locale.US))
                .format((double) size / divider) + " " + unitName;
    }

    private static void addToTable(Match infrastructure, String elementName, String label, Map<String, String> table) {
        var hostName = infrastructure.child(elementName).text();
        if (hostName != null) {
            table.put(label, hostName);
        }
    }

    private void addSections(Element element, TestNode node) {
        createTagsSection(element).ifPresent(node.sections::add);
        createSourcesSection(element).ifPresent(node.sections::add);
        createResultSection(element).ifPresent(node.sections::add);
        createAttachmentsSection(element).ifPresent(node.sections::add);
    }

    private static Optional<Section> createTagsSection(Element element) {
        var tags = $(element)
                .child("metadata")
                .child("tags")
                .children("tag")
                .map(e -> e.element().getTextContent());
        if (tags.isEmpty()) {
            return Optional.empty();
        }
        Section section = new Section("Tags");
        section.blocks.add(new Labels(tags));
        return Optional.of(section);
    }

    private static Optional<Section> createSourcesSection(Element element) {
        var children = $(element).children("sources").children().get();
        if (children.isEmpty()) {
            return Optional.empty();
        }
        var content = new ArrayList<Section>();
        children.stream()
                .map(child -> {
                    var type = child.getLocalName();
                    if (child.getLocalName().endsWith("Source")) {
                        type = child.getLocalName().substring(0, child.getLocalName().length() - "Source".length());
                    }
                    var subsection = new Section(capitalize(type));
                    var attributes = new LinkedHashMap<String, String>();
                    stream(child.getAttributes()).forEach(it -> attributes.put(it.getNodeName(), it.getNodeValue()));
                    subsection.blocks.add(new KeyValuePairs(attributes));
                    return subsection;
                })
                .forEach(content::add);
        Section section = new Section("Sources");
        section.blocks.add(new Subsections(content));
        return Optional.of(section);
    }

    private static Optional<Section> createAttachmentsSection(Element element) {
        var children = $(element).children("attachments").children().get();
        if (children.isEmpty()) {
            return Optional.empty();
        }
        var content = new ArrayList<Section>();
        children.stream()
                .map(child -> {
                    var type = child.getLocalName();
                    var subsection = new Section(capitalize(type));
                    var attributes = new LinkedHashMap<String, String>();
                    stream(child.getAttributes()).forEach(it -> attributes.put(it.getNodeName(), it.getNodeValue()));
                    if ("data".equals(child.getLocalName())) {
                        $(child).children("entry").forEach(entry -> {
                            var key = entry.getAttribute("key");
                            var value = entry.getTextContent();
                            attributes.put(key, value);
                        });
                    }
                    subsection.blocks.add(new KeyValuePairs(attributes));
                    return subsection;
                })
                .forEach(content::add);
        Section section = new Section("Attachments");
        section.blocks.add(new Subsections(content));
        return Optional.of(section);
    }

    private static Optional<Section> createResultSection(Element element) {
        var result = $(element).child("result");
        var content = new ArrayList<Section>();
        var reason = result.child("reason").text();
        if (reason != null) {
            Section subsection = new Section("Reason");
            subsection.blocks.add(new Paragraph(reason));
            content.add(subsection);
        }
        content.addAll(result.children("throwable").map(throwable -> {
            var type = throwable.match().getAttribute("type");
            var stackTrace = throwable.match().getTextContent();
            Section subsection = new Section(type);
            subsection.blocks.add(new PreFormattedOutput(stackTrace));
            return subsection;
        }));
        if (content.isEmpty()) {
            return Optional.empty();
        }
        var section = new Section("Result");
        section.blocks.add(new Subsections(content));
        return Optional.of(section);
    }

    private static String capitalize(String value) {
        return value.substring(0, 1).toUpperCase(Locale.ROOT) + value.substring(1);
    }

    static class IdGenerator {
        private int nextId = 1;

        String next() {
            return Integer.toString(nextId++);
        }
    }

    private static Element parseDom(Path xmlFile) throws ParserConfigurationException, SAXException, IOException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        DocumentBuilder builder = factory.newDocumentBuilder();

        Document sourceDocument = builder.parse(xmlFile.toFile());
        return sourceDocument.getDocumentElement();
    }

    private String readTemplate() throws IOException {
        try (var template = getClass().getResourceAsStream("template.html")) {
            return new String(requireNonNull(template).readAllBytes());
        }
    }
}
