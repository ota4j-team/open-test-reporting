package org.opentest4j.reporting.tooling.htmlreport;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.json.JsonSanitizer;
import org.opentest4j.reporting.events.core.Result;
import org.opentest4j.reporting.schema.Namespace;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import static java.util.Objects.requireNonNull;
import static org.opentest4j.reporting.tooling.util.DomUtils.matches;
import static org.opentest4j.reporting.tooling.util.DomUtils.stream;

public class DefaultHtmlReportWriter implements HtmlReportWriter {

    @Override
    public void writeHtmlReport(Path xmlFile, Path htmlFile) throws Exception {

        // TODO Check whether XML file is in hierarchical format. If not, convert it first

        var rootElement = parseDom(xmlFile);
        var idGenerator = new IdGenerator();
        var tree = new LinkedHashMap<String, List<String>>();
        var testNodes = new ArrayList<TestNode>();
        var roots = new ArrayList<String>();

        for (Node child = rootElement.getFirstChild(); child != null; child = child.getNextSibling()) {
            if (child instanceof Element && Namespace.REPORTING_HIERARCHY.getUri().equals(child.getNamespaceURI())
                    && "root".equals(child.getLocalName())) {
                roots.add(visitNode((Element) child, idGenerator, new ArrayDeque<>(), tree, testNodes));
            }
        }

        var jsonMapper = new ObjectMapper();
        var json = JsonSanitizer.sanitize(jsonMapper.writeValueAsString(roots));
        var javaScript = "\n    globalThis.roots = " + json + ";";

        json = JsonSanitizer.sanitize(jsonMapper.writeValueAsString(tree));
        javaScript += "\n    globalThis.children = " + json + ";";

        jsonMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
        json = JsonSanitizer.sanitize(jsonMapper.writeValueAsString(testNodes));
        javaScript += "\n    globalThis.testNodes = " + json + ";";

        var content = readTemplate().replace("<script src=\"./init.js\"></script>", "<script>" + javaScript + "\n  </script>");
        Files.writeString(htmlFile, content);
    }

    static class TestNode {

        public final String id;
        public final String name;
        public final String status;

        TestNode(String id, String name, String status) {
            this.id = id;
            this.name = name;
            this.status = status;
        }
    }

    private String visitNode(Element root, IdGenerator idGenerator, Deque<String> parentIds, Map<String, List<String>> children, List<TestNode> testNodes) {
        String currentId = idGenerator.next();

        String status = stream(root.getChildNodes()) //
                .filter(it -> it instanceof Element && matches(Result.ELEMENT, (Element) it))
                .findAny()
                .map(it -> ((Element) it).getAttribute(Result.STATUS.getSimpleName()))
                .orElse(null);

        testNodes.add(new TestNode(currentId, root.getAttribute("name"), status));

        if (!parentIds.isEmpty()) {
            String parentId = parentIds.peek();
            children.computeIfAbsent(parentId, __ -> new ArrayList<>());
            children.get(parentId).add(currentId);
        }
        parentIds.push(currentId);
        for (Node child = root.getFirstChild(); child != null; child = child.getNextSibling()) {
            if (child instanceof Element && Namespace.REPORTING_HIERARCHY.getUri().equals(child.getNamespaceURI())
                    && "child".equals(child.getLocalName())) {
                visitNode((Element) child, idGenerator, parentIds, children, testNodes);
            }
        }
        parentIds.pop();

        return currentId;
    }

    static class IdGenerator {
        private int nextId = 1;

        String next() {
            return Integer.toString(nextId++);
        }
    }

    private static Element parseDom(Path xmlFile) throws ParserConfigurationException, SAXException, IOException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        DocumentBuilder builder = factory.newDocumentBuilder();

        Document sourceDocument = builder.parse(xmlFile.toFile());
        return sourceDocument.getDocumentElement();
    }

    private String readTemplate() throws IOException {
        try (var template = getClass().getResourceAsStream("template.html")) {
            return new String(requireNonNull(template).readAllBytes());
        }
    }
}
