package org.opentest4j.reporting.tooling.htmlreport;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonSubTypes.Type;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.json.JsonSanitizer;
import org.opentest4j.reporting.events.core.Result;
import org.opentest4j.reporting.events.core.Sources;
import org.opentest4j.reporting.schema.Namespace;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static java.util.Objects.requireNonNull;
import static org.opentest4j.reporting.tooling.util.DomUtils.matches;
import static org.opentest4j.reporting.tooling.util.DomUtils.stream;

public class DefaultHtmlReportWriter implements HtmlReportWriter {

    @Override
    public void writeHtmlReport(Path xmlFile, Path htmlFile) throws Exception {

        // TODO Check whether XML file is in hierarchical format. If not, convert it first

        var rootElement = parseDom(xmlFile);
        var idGenerator = new IdGenerator();
        var tree = new LinkedHashMap<String, List<String>>();
        var testNodes = new ArrayList<TestNode>();
        var roots = new ArrayList<String>();

        for (Node child = rootElement.getFirstChild(); child != null; child = child.getNextSibling()) {
            if (child instanceof Element && Namespace.REPORTING_HIERARCHY.getUri().equals(child.getNamespaceURI())
                    && "root".equals(child.getLocalName())) {
                roots.add(visitNode((Element) child, idGenerator, new ArrayDeque<>(), tree, testNodes));
            }
        }

        var jsonMapper = new ObjectMapper();
        var json = JsonSanitizer.sanitize(jsonMapper.writeValueAsString(roots));
        var javaScript = "\n    globalThis.roots = " + json + ";";

        json = JsonSanitizer.sanitize(jsonMapper.writeValueAsString(tree));
        javaScript += "\n    globalThis.children = " + json + ";";

        jsonMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
        json = JsonSanitizer.sanitize(jsonMapper.writeValueAsString(testNodes));
        javaScript += "\n    globalThis.testNodes = " + json + ";";

        var content = readTemplate().replace("<script src=\"./init.js\"></script>", "<script>" + javaScript + "\n  </script>");
        Files.writeString(htmlFile, content);
    }

    static class TestNode {

        public final String id;
        public final String name;
        public final String status;
        public final List<Section> sections = new ArrayList<>();

        TestNode(String id, String name, String status) {
            this.id = id;
            this.name = name;
            this.status = status;
        }
    }

    @JsonTypeInfo(
            use = JsonTypeInfo.Id.NAME,
            property = "type")
    @JsonSubTypes({
            @Type(value = EmptySection.class, name = "empty"),
            @Type(value = PreFormattedOutputSection.class, name = "pre")
    })
    static abstract class Section {

        public final String title;

        Section(String title) {
            this.title = title;
        }
    }

    static class PreFormattedOutputSection extends Section {

        public final String content;

        PreFormattedOutputSection(String title, String content) {
            super(title);
            this.content = content;
        }
    }

    static class EmptySection extends Section {

        public final String content;

        EmptySection(String title, String content) {
            super(title);
            this.content = content;
        }
    }

    private String visitNode(Element node, IdGenerator idGenerator, Deque<String> parentIds, Map<String, List<String>> children, List<TestNode> testNodes) {
        String currentId = idGenerator.next();

        String status = stream(node.getChildNodes()) //
                .filter(it -> it instanceof Element && matches(Result.ELEMENT, (Element) it))
                .findAny()
                .map(it -> ((Element) it).getAttribute(Result.STATUS.getSimpleName()))
                .orElse(null);

        var testNode = new TestNode(currentId, node.getAttribute("name"), status);
        testNodes.add(testNode);

        addSections(node, testNode);

        if (!parentIds.isEmpty()) {
            String parentId = parentIds.peek();
            children.computeIfAbsent(parentId, __ -> new ArrayList<>());
            children.get(parentId).add(currentId);
        }
        parentIds.push(currentId);
        for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {
            if (child instanceof Element && Namespace.REPORTING_HIERARCHY.getUri().equals(child.getNamespaceURI())
                    && "child".equals(child.getLocalName())) {
                visitNode((Element) child, idGenerator, parentIds, children, testNodes);
            }
        }
        parentIds.pop();

        return currentId;
    }

    private void addSections(Element element, TestNode node) {
        node.sections.add(stream(element.getChildNodes())
                .filter(it -> it instanceof Element && Sources.ELEMENT.getSimpleName().equals(it.getLocalName()))
                .map(it -> (Element) it)
                .findAny().map(sources -> stream(sources.getChildNodes())
                        .filter(it -> it instanceof Element)
                        .collect(Collectors.toList()))
                .map(sources -> {
                    if (sources.size() == 1) {
                        return (Section) new PreFormattedOutputSection("Source", convertSourceElementToString(sources.get(0)));
                    } else {
                        return new PreFormattedOutputSection("Sources", sources.stream().map(DefaultHtmlReportWriter::convertSourceElementToString).collect(Collectors.joining("\n")));
                    }
                })
                .orElseGet(() -> new EmptySection("Source", "No source information available")));
    }

    private static String convertSourceElementToString(Node source) {
        return source.getLocalName() + ":\n" + stream(source.getAttributes()).map(a -> a.getNodeName() + "=" + a.getNodeValue()).collect(Collectors.joining("\n"));
    }

    static class IdGenerator {
        private int nextId = 1;

        String next() {
            return Integer.toString(nextId++);
        }
    }

    private static Element parseDom(Path xmlFile) throws ParserConfigurationException, SAXException, IOException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        DocumentBuilder builder = factory.newDocumentBuilder();

        Document sourceDocument = builder.parse(xmlFile.toFile());
        return sourceDocument.getDocumentElement();
    }

    private String readTemplate() throws IOException {
        try (var template = getClass().getResourceAsStream("template.html")) {
            return new String(requireNonNull(template).readAllBytes());
        }
    }
}
