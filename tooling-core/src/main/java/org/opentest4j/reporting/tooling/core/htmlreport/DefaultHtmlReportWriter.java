/*
 * Copyright 2021-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.opentest4j.reporting.tooling.core.htmlreport;

import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
import com.google.gson.JsonSerializer;
import org.opentest4j.reporting.events.core.Result;
import org.opentest4j.reporting.events.root.Events;
import org.opentest4j.reporting.schema.Namespace;
import org.opentest4j.reporting.schema.QualifiedName;
import org.opentest4j.reporting.tooling.core.converter.DefaultConverter;
import org.opentest4j.reporting.tooling.spi.htmlreport.Block;
import org.opentest4j.reporting.tooling.spi.htmlreport.Contributor;
import org.opentest4j.reporting.tooling.spi.htmlreport.KeyValuePairs;
import org.opentest4j.reporting.tooling.spi.htmlreport.Labels;
import org.opentest4j.reporting.tooling.spi.htmlreport.Paragraph;
import org.opentest4j.reporting.tooling.spi.htmlreport.PreFormattedOutput;
import org.opentest4j.reporting.tooling.spi.htmlreport.Section;
import org.opentest4j.reporting.tooling.spi.htmlreport.Subsections;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Duration;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.ServiceLoader;
import java.util.Set;
import java.util.function.BiFunction;

import static java.util.Comparator.comparing;
import static java.util.Objects.requireNonNull;
import static org.opentest4j.reporting.tooling.core.util.DomUtils.matches;
import static org.opentest4j.reporting.tooling.core.util.DomUtils.stream;

/**
 * Default implementation of {@link HtmlReportWriter}.
 */
public class DefaultHtmlReportWriter implements HtmlReportWriter {

	private static final QualifiedName ROOT_ELEMENT = QualifiedName.of(Namespace.REPORTING_HIERARCHY, "root");
	private static final QualifiedName CHILD_ELEMENT = QualifiedName.of(Namespace.REPORTING_HIERARCHY, "child");

	private final ServiceLoader<Contributor> contributors = ServiceLoader.load(Contributor.class);

	@Override
	public void writeHtmlReport(List<Path> xmlFiles, Path htmlFile) throws Exception {

		var idGenerator = new IdGenerator();
		var executions = new ArrayList<Execution>();

		for (Path xmlFile : xmlFiles) {
			var rootElement = parseDom(xmlFile);
			var name = String.format(xmlFile.getFileName().toString());
			executions.add(extractData(idGenerator, rootElement, name));
		}

		var javaScript = toJavascript(executions);

		var content = readTemplate().replace("<script src=\"./init.js\"></script>",
			"<script>\n    " + javaScript + "\n  </script>");
		Files.writeString(htmlFile, content);
	}

	private static String toJavascript(List<Execution> executions) {
		var gson = new GsonBuilder() //
				.registerTypeHierarchyAdapter(Section.class,
					(JsonSerializer<Section>) (section, typeOfSrc, context) -> {
						var jsonObject = new JsonObject();
						jsonObject.addProperty("title", section.getTitle());
						jsonObject.add("blocks", context.serialize(section.getBlocks()));
						return jsonObject;
					}) //
				.registerTypeHierarchyAdapter(KeyValuePairs.class, blockSerializer("kvp")) //
				.registerTypeHierarchyAdapter(Labels.class, blockSerializer("labels")) //
				.registerTypeHierarchyAdapter(Paragraph.class, blockSerializer("p")) //
				.registerTypeHierarchyAdapter(PreFormattedOutput.class, blockSerializer("pre")) //
				.registerTypeHierarchyAdapter(Subsections.class, blockSerializer("sub")) //
				.disableJdkUnsafe() //
				.create();

		return "globalThis.testExecutions = " + gson.toJson(executions) + ";";
	}

	private static JsonSerializer<Block<?>> blockSerializer(String type) {
		return (block, typeOfSrc, context) -> {
			var jsonObject = new JsonObject();
			jsonObject.addProperty("type", type);
			jsonObject.add("content", context.serialize(block.getContent()));
			return jsonObject;
		};
	}

	private Execution extractData(IdGenerator idGenerator, Element rootElement, String name) {
		var execution = new Execution(idGenerator.next(), name);
		addSections(rootElement, execution);

		for (Node child = rootElement.getFirstChild(); child != null; child = child.getNextSibling()) {
			if (child instanceof Element && matches(ROOT_ELEMENT, (Element) child)) {
				var root = visitNode((Element) child, idGenerator, new ArrayDeque<>(), execution);
				execution.durationMillis += root.durationMillis;
				execution.roots.add(root.id);
			}
		}
		return execution;
	}

	private static class Execution {

		public final String id;
		public final String name;
		public long durationMillis;

		public final List<Section> sections = new ArrayList<>();

		public final List<String> roots = new ArrayList<>();
		public final Map<String, ChildMetadata> children = new LinkedHashMap<>();
		public final List<TestNode> testNodes = new ArrayList<>();

		Execution(String id, String name) {
			this.id = id;
			this.name = name;
		}
	}

	private static class ChildMetadata {

		public final List<String> ids = new ArrayList<>();
		public final Set<String> childStatuses = new HashSet<>();

		private void addChild(String childId, String status) {
			ids.add(childId);
			if (status != null) {
				childStatuses.add(status);
			}
		}

	}

	private static class TestNode {

		public final String id;
		public final String name;
		public final long durationMillis;

		public final String status;

		public final List<Section> sections = new ArrayList<>();

		TestNode(String id, String name, long durationMillis, String status) {
			this.id = id;
			this.name = name;
			this.durationMillis = durationMillis;
			this.status = status;
		}
	}

	private TestNode visitNode(Element node, IdGenerator idGenerator, Deque<String> parentIds, Execution execution) {
		String currentId = idGenerator.next();

		String status = stream(node.getChildNodes()) //
				.filter(it -> it instanceof Element && matches(Result.ELEMENT, (Element) it)).findAny().map(
					it -> ((Element) it).getAttribute(Result.STATUS.getSimpleName())).orElse(null);

		var duration = Duration.parse(node.getAttribute("duration"));
		var testNode = new TestNode(currentId, node.getAttribute("name"), duration.toMillis(), status);
		execution.testNodes.add(testNode);

		addSections(node, testNode);

		ChildMetadata parentChildMetadata = null;
		if (!parentIds.isEmpty()) {
			String parentId = parentIds.peek();
			parentChildMetadata = execution.children.computeIfAbsent(parentId, __ -> new ChildMetadata());
			parentChildMetadata.addChild(currentId, status);
		}
		parentIds.push(currentId);
		for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {
			if (child instanceof Element && matches(CHILD_ELEMENT, (Element) child)) {
				visitNode((Element) child, idGenerator, parentIds, execution);
			}
		}
		parentIds.pop();
		ChildMetadata currentNodeChildMetadata = execution.children.get(currentId);
		if (currentNodeChildMetadata != null && parentChildMetadata != null) {
			parentChildMetadata.childStatuses.addAll(currentNodeChildMetadata.childStatuses);
		}

		return testNode;
	}

	private void addSections(Element element, Execution execution) {
		contributeSections(element, Contributor::contributeSectionsForExecution, execution.sections);
	}

	private void addSections(Element element, TestNode node) {
		contributeSections(element, Contributor::contributeSectionsForTestNode, node.sections);
	}

	private void contributeSections(Element element, BiFunction<Contributor, Element, List<Section>> call,
			List<Section> sections) {
		contributors.stream().flatMap(it -> call.apply(it.get(), element).stream()).sorted(
			comparing(Section::getOrder)).forEach(sections::add);
	}

	static class IdGenerator {
		private int nextId = 1;

		String next() {
			return Integer.toString(nextId++);
		}
	}

	private static Element parseDom(Path xmlFile) throws Exception {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		factory.setNamespaceAware(true);
		DocumentBuilder builder = factory.newDocumentBuilder();

		Document sourceDocument = builder.parse(xmlFile.toFile());
		Element element = sourceDocument.getDocumentElement();

		if (matches(Events.ELEMENT, element)) {
			return new DefaultConverter().convert(element).getDocumentElement();
		}

		return element;
	}

	private String readTemplate() throws IOException {
		try (var template = getClass().getResourceAsStream("template.html")) {
			return new String(requireNonNull(template).readAllBytes());
		}
	}
}
